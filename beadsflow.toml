beads_dir = ".beads"
beads_no_db = false
interval_seconds = 30
log_level = "info"
implementer = "codex"
reviewer = "claude"

# This config is intended for running `beadsflow` against this repo.
#
# Key differences from the older approach:
# - Use `comment_mode = "stdout"` so beadsflow posts comments itself (keeps scripts simple and avoids huge comments).
# - Keep stdout comments short to prevent `.beads/issues.jsonl` lines from exceeding Beads' scanner limit.
#
# Note: `beads_no_db = true` is currently unreliable with our Beads CLI usage because `bd --no-db comment` writes to the
# sqlite db but does not immediately update `.beads/issues.jsonl`, so beadsflow fails to observe marker transitions.
#
# Note: this repo has multiple `podcast-pipeline-*` prefixes (hash-suffixed), so `bd --no-db` needs
# `BD_ISSUE_PREFIX=podcast-pipeline` in the environment (see `Justfile` helpers).

[implementers.codex]
comment_mode = "stdout"
comment_prefix = "Ready for review:\n\n"
comment_suffix = "\n\nValidation:\n- (run by reviewer)\n"
require_git_changes = true
command = """bash -lc 'set -euo pipefail
export BEADS_NO_DAEMON=1
export BEADS_DIR="$PWD/.beads"
export BD_ISSUE_PREFIX="${BD_ISSUE_PREFIX:-podcast-pipeline}"
issue="$BEADSFLOW_ISSUE_ID"
epic="$BEADSFLOW_EPIC_ID"

export BEADSFLOW_MAX_COMMENT_BYTES="${BEADSFLOW_MAX_COMMENT_BYTES:-800}"
export BEADSFLOW_MAX_COMMENT_LINES="${BEADSFLOW_MAX_COMMENT_LINES:-40}"

cap_comment() {
  # With `set -o pipefail`, truncation can cause SIGPIPE upstream; never fail the script.
  sed -n "1,${BEADSFLOW_MAX_COMMENT_LINES}p" | head -c "${BEADSFLOW_MAX_COMMENT_BYTES}" || true
}

msgfile="$(mktemp -t beadsflow-codex-msg.XXXXXX)"
cleanup() { rm -f "$msgfile"; }
trap cleanup EXIT

set +e
# Redirect codex stdout to stderr so beadsflow only posts the curated summary below.
codex --ask-for-approval never exec --sandbox workspace-write --output-last-message "$msgfile" \
  "Implement bead ${issue} under epic ${epic}. First, read the bead and its dependency chain: bd --no-daemon show ${issue}; bd --no-daemon dep tree ${issue}. Implement the acceptance criteria by editing files in this repo. Ensure there is a non-empty git diff when done. Do not post Beads comments yourself. Do not run tests, type checks, lint/format, or install commands; the reviewer handles validation. Keep your final summary concise (<= ~8 bullets)." 1>&2
codex_rc=$?
set -e

if [ -s "$msgfile" ]; then
  cat "$msgfile" | cap_comment || true
else
  printf "%s\n" "(no summary captured from codex)" | cap_comment || true
fi

if [ "${codex_rc}" != "0" ]; then
  printf "\n\nNote: codex exited with code %s.\n" "${codex_rc}" | cap_comment || true
fi
'"""

[reviewers.claude]
comment_mode = "stdout"
command = """bash -lc 'set -euo pipefail
issue="$BEADSFLOW_ISSUE_ID"
epic="$BEADSFLOW_EPIC_ID"

export BEADSFLOW_MAX_COMMENT_BYTES="${BEADSFLOW_MAX_REVIEW_BYTES:-2000}"
export BEADSFLOW_MAX_COMMENT_LINES="${BEADSFLOW_MAX_REVIEW_LINES:-80}"
cap_comment() {
  sed -n "1,${BEADSFLOW_MAX_COMMENT_LINES}p" | head -c "${BEADSFLOW_MAX_COMMENT_BYTES}" || true
}

out="$(claude -p "Review bead ${issue} under epic ${epic}.

Checklist:
- Read the bead and confirm the acceptance criteria are met.
- Review the actual code changes (git diff) for correctness, edge cases, and maintainability.
- Confirm the latest Ready for review comment includes a Validation section; if anything is missing/failed, request changes.

Important:
- Base your decision on the current code state plus the latest Ready for review comment only.

Respond with a single Beads comment. The first non-empty line must be exactly LGTM or start with Changes requested:. Do not wrap that marker in markdown/backticks.")"

# Defensive: some CLIs prepend meta text. Force a valid marker on the first non-empty line.
first_non_empty="$(printf "%s" "$out" | awk "NF{print; exit}")"
case "$first_non_empty" in
  LGTM|"Changes requested:"*) ;;
  *)
    marker="$(printf "%s" "$out" | awk "
      /^[[:space:]]*LGTM[[:space:]]*$/ {print \\\"LGTM\\\"; exit}
      /^[[:space:]]*Changes requested:/ {sub(/^[[:space:]]*/, \\\"\\\"); print; exit}
    ")"
    if [ -z "$marker" ]; then
      marker="Changes requested:"
    fi
    out="$(cat <<EOF
$marker

$out
EOF
)"
    ;;
esac

printf "%s" "$out"
'"""

[reviewers.local]
comment_mode = "stdout"
command = """bash -lc 'set -euo pipefail
issue="$BEADSFLOW_ISSUE_ID"
epic="$BEADSFLOW_EPIC_ID"

# Keep stdout small; write full gate output to files.
export BEADSFLOW_MAX_COMMENT_BYTES="${BEADSFLOW_MAX_COMMENT_BYTES:-800}"
export BEADSFLOW_MAX_COMMENT_LINES="${BEADSFLOW_MAX_COMMENT_LINES:-40}"
cap_comment() {
  sed -n "1,${BEADSFLOW_MAX_COMMENT_LINES}p" | head -c "${BEADSFLOW_MAX_COMMENT_BYTES}" || true
}

ts="$(date +%Y%m%d-%H%M%S)"
gate_dir="$PWD/.beads/logs/beadsflow/gates/${issue}/${ts}"
mkdir -p "$gate_dir"
lint_log="$gate_dir/lint.log"
typecheck_log="$gate_dir/typecheck.log"
test_log="$gate_dir/test.log"

lint_rc=0
if just lint >"$lint_log" 2>&1; then :; else lint_rc=$?; fi
typecheck_rc=0
if just typecheck >"$typecheck_log" 2>&1; then :; else typecheck_rc=$?; fi
test_rc=0
if just test >"$test_log" 2>&1; then :; else test_rc=$?; fi

if [ "$lint_rc" = "0" ] && [ "$typecheck_rc" = "0" ] && [ "$test_rc" = "0" ]; then
  printf "%s\n" "LGTM"
  printf "\n%s\n" "Validation:"
  printf "%s\n" "- just lint"
  printf "%s\n" "- just typecheck"
  printf "%s\n" "- just test"
  exit 0
fi

printf "%s\n" "Changes requested: quality gates failing" | cap_comment || true
printf "\n%s\n" "Validation:" | cap_comment || true

if [ "$lint_rc" = "0" ]; then
  printf "%s\n" "- just lint: PASS" | cap_comment || true
else
  printf "%s\n" "- just lint: FAIL (${lint_rc}) (log: ${lint_log})" | cap_comment || true
fi

if [ "$typecheck_rc" = "0" ]; then
  printf "%s\n" "- just typecheck: PASS" | cap_comment || true
else
  printf "%s\n" "- just typecheck: FAIL (${typecheck_rc}) (log: ${typecheck_log})" | cap_comment || true
fi

if [ "$test_rc" = "0" ]; then
  printf "%s\n" "- just test: PASS" | cap_comment || true
else
  printf "%s\n" "- just test: FAIL (${test_rc}) (log: ${test_log})" | cap_comment || true
fi

exit 0
'"""

[run]
max_iterations = 500
resume_in_progress = true
selection_strategy = "priority_then_oldest"
on_command_failure = "stop"
command_timeout_seconds = 7200
